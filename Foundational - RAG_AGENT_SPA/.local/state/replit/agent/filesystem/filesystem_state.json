{"file_contents":{"main.py":{"content":"import subprocess\nimport sys\nimport os\n\n# Install dependencies first\nprint(\"Installing dependencies...\")\ntry:\n    subprocess.check_call(\n        [sys.executable, \"-m\", \"pip\", \"install\", \"-r\", \"requirements.txt\"])\n    print(\"âœ… Dependencies installed successfully\")\nexcept subprocess.CalledProcessError as e:\n    print(f\"âŒ Error installing dependencies: {e}\")\n    sys.exit(1)\n\n# Now import the modules\nfrom fastapi import FastAPI, HTTPException, UploadFile, File\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel\nimport openai\nfrom typing import List, Optional\nimport uvicorn\n\napp = FastAPI(title=\"RAG Document QA System\", version=\"1.0.0\")\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Simple document storage\ndocuments = []\n\n\nclass QueryRequest(BaseModel):\n    query: str\n\n\nclass QueryResponse(BaseModel):\n    answer: str\n    confidence: float\n\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"RAG Document QA System is running!\"}\n\n\n@app.post(\"/upload\")\nasync def upload_documents(files: List[UploadFile] = File(...)):\n    global documents\n    try:\n        processed_count = 0\n        for file in files:\n            # Accept both PDF and text files\n            if file.filename.endswith(('.pdf', '.txt')):\n                # Save file temporarily\n                file_path = f\"temp_{file.filename}\"\n                with open(file_path, \"wb\") as buffer:\n                    content = await file.read()\n                    buffer.write(content)\n\n                # Read text content\n                if file.filename.endswith('.txt'):\n                    with open(file_path, 'r', encoding='utf-8') as text_file:\n                        text = text_file.read()\n                else:\n                    # For PDF files, we'll use a simple approach\n                    # You can install PyPDF2 later if needed\n                    text = f\"PDF file: {file.filename} (content extraction available with PyPDF2)\"\n\n                documents.append({\"filename\": file.filename, \"content\": text})\n\n                # Clean up\n                os.remove(file_path)\n                processed_count += 1\n\n        return {\n            \"message\": f\"Successfully processed {processed_count} documents\",\n            \"documents_processed\": processed_count\n        }\n\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@app.post(\"/query\", response_model=QueryResponse)\nasync def query_documents(request: QueryRequest):\n    try:\n        if not documents:\n            raise HTTPException(\n                status_code=400,\n                detail=\"No documents uploaded. Please upload documents first.\")\n\n        # Get OpenAI API key\n        api_key = os.getenv(\"OPENAI_API_KEY\")\n        if not api_key:\n            raise HTTPException(status_code=500,\n                                detail=\"OpenAI API key not set\")\n\n        # Create context from documents\n        context = \"\"\n        for doc in documents:\n            context += f\"Document: {doc['filename']}\\n{doc['content']}\\n\\n\"\n\n        # Create prompt\n        prompt = f\"\"\"\n        Based on the following documents, answer this question: {request.query}\n\n        Documents:\n        {context}\n\n        Answer:\n        \"\"\"\n\n        # Get response from OpenAI\n        client = openai.OpenAI(api_key=api_key)\n        response = client.chat.completions.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[{\n                \"role\":\n                \"system\",\n                \"content\":\n                \"You are a helpful assistant that answers questions based on provided documents.\"\n            }, {\n                \"role\": \"user\",\n                \"content\": prompt\n            }],\n            max_tokens=1000,\n            temperature=0.1)\n\n        answer = response.choices[0].message.content\n\n        return QueryResponse(answer=answer, confidence=0.8)\n\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@app.get(\"/documents/count\")\nasync def get_document_count():\n    return {\"document_count\": len(documents)}\n\n\n@app.delete(\"/documents\")\nasync def clear_documents():\n    global documents\n    documents = []\n    return {\"message\": \"All documents cleared successfully\"}\n\n\nif __name__ == \"__main__\":\n    print(\"ðŸš€ Starting RAG Document QA System...\")\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n","size_bytes":4479},"backend/main.py":{"content":"from fastapi import FastAPI, HTTPException, UploadFile, File\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel\nimport os\nfrom dotenv import load_dotenv\nimport uvicorn\nfrom typing import List, Optional\nimport logging\n\nfrom rag_system import RAGSystem\nfrom document_processor import DocumentProcessor\n\n# Load environment variables\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(title=\"RAG Document QA System\", version=\"1.0.0\")\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Initialize RAG system\nrag_system = None\ndocument_processor = DocumentProcessor()\n\nclass QueryRequest(BaseModel):\n    query: str\n    max_results: Optional[int] = 5\n\nclass QueryResponse(BaseModel):\n    answer: str\n    sources: List[str]\n    confidence: float\n\nclass UploadResponse(BaseModel):\n    message: str\n    documents_processed: int\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    \"\"\"Initialize the RAG system on startup\"\"\"\n    global rag_system\n    try:\n        rag_system = RAGSystem()\n        logger.info(\"RAG system initialized successfully\")\n    except Exception as e:\n        logger.error(f\"Failed to initialize RAG system: {e}\")\n        raise\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Health check endpoint\"\"\"\n    return {\"message\": \"RAG Document QA System is running!\"}\n\n@app.post(\"/upload\", response_model=UploadResponse)\nasync def upload_documents(files: List[UploadFile] = File(...)):\n    \"\"\"Upload and process PDF documents\"\"\"\n    try:\n        if not rag_system:\n            raise HTTPException(status_code=500, detail=\"RAG system not initialized\")\n\n        processed_count = 0\n        for file in files:\n            if file.filename.endswith('.pdf'):\n                # Save uploaded file temporarily\n                file_path = f\"temp_{file.filename}\"\n                with open(file_path, \"wb\") as buffer:\n                    content = await file.read()\n                    buffer.write(content)\n\n                # Process the document\n                documents = document_processor.process_pdf(file_path)\n                rag_system.add_documents(documents)\n\n                # Clean up temporary file\n                os.remove(file_path)\n                processed_count += 1\n\n        return UploadResponse(\n            message=f\"Successfully processed {processed_count} documents\",\n            documents_processed=processed_count\n        )\n\n    except Exception as e:\n        logger.error(f\"Error uploading documents: {e}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post(\"/query\", response_model=QueryResponse)\nasync def query_documents(request: QueryRequest):\n    \"\"\"Query the RAG system with a question\"\"\"\n    try:\n        if not rag_system:\n            raise HTTPException(status_code=500, detail=\"RAG system not initialized\")\n\n        if not rag_system.has_documents():\n            raise HTTPException(status_code=400, detail=\"No documents uploaded. Please upload PDF documents first.\")\n\n        # Get response from RAG system\n        response = rag_system.query(request.query, max_results=request.max_results)\n\n        return QueryResponse(\n            answer=response[\"answer\"],\n            sources=response[\"sources\"],\n            confidence=response[\"confidence\"]\n        )\n\n    except Exception as e:\n        logger.error(f\"Error querying documents: {e}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/documents/count\")\nasync def get_document_count():\n    \"\"\"Get the number of documents in the system\"\"\"\n    if not rag_system:\n        raise HTTPException(status_code=500, detail=\"RAG system not initialized\")\n\n    return {\"document_count\": rag_system.get_document_count()}\n\n@app.delete(\"/documents\")\nasync def clear_documents():\n    \"\"\"Clear all documents from the system\"\"\"\n    try:\n        if not rag_system:\n            raise HTTPException(status_code=500, detail=\"RAG system not initialized\")\n\n        rag_system.clear_documents()\n        return {\"message\": \"All documents cleared successfully\"}\n\n    except Exception as e:\n        logger.error(f\"Error clearing documents: {e}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)","size_bytes":4405},"backend/rag_system.py":{"content":"import os\nimport logging\nfrom typing import List, Dict, Any\nimport openai\nfrom langchain.schema import Document\nimport json\n\nlogger = logging.getLogger(__name__)\n\nclass RAGSystem:\n    def __init__(self):\n        \"\"\"Initialize the RAG system with OpenAI\"\"\"\n        self.openai_api_key = os.getenv(\"OPENAI_API_KEY\")\n        if not self.openai_api_key:\n            raise ValueError(\"OPENAI_API_KEY environment variable is required\")\n\n        # Initialize OpenAI client\n        self.client = openai.OpenAI(api_key=self.openai_api_key)\n\n        # Simple document storage\n        self.documents = []\n\n        logger.info(\"RAG system initialized successfully\")\n\n    def add_documents(self, documents: List[Document]):\n        \"\"\"Add documents to the system\"\"\"\n        try:\n            self.documents.extend(documents)\n            logger.info(f\"Added {len(documents)} documents to system\")\n        except Exception as e:\n            logger.error(f\"Error adding documents: {e}\")\n            raise\n\n    def query(self, question: str, max_results: int = 5) -> Dict[str, Any]:\n        \"\"\"Query the RAG system with a question\"\"\"\n        try:\n            if not self.documents:\n                raise ValueError(\"No documents available. Please upload documents first.\")\n\n            # Create context from documents\n            context = \"\"\n            sources = []\n\n            for doc in self.documents[:max_results]:\n                context += doc.page_content + \"\\n\\n\"\n                if hasattr(doc, 'metadata') and 'source' in doc.metadata:\n                    sources.append(doc.metadata['source'])\n\n            # Create prompt\n            prompt = f\"\"\"\n            Based on the following documents, answer the question: {question}\n\n            Documents:\n            {context}\n\n            Answer:\n            \"\"\"\n\n            # Get response from OpenAI\n            response = self.client.chat.completions.create(\n                model=\"gpt-3.5-turbo\",\n                messages=[\n                    {\"role\": \"system\", \"content\": \"You are a helpful assistant that answers questions based on the provided documents.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ],\n                max_tokens=1000,\n                temperature=0.1\n            )\n\n            answer = response.choices[0].message.content\n\n            return {\n                \"answer\": answer,\n                \"sources\": list(set(sources)),\n                \"confidence\": 0.8\n            }\n\n        except Exception as e:\n            logger.error(f\"Error querying RAG system: {e}\")\n            raise\n\n    def has_documents(self) -> bool:\n        \"\"\"Check if there are documents in the system\"\"\"\n        return len(self.documents) > 0\n\n    def get_document_count(self) -> int:\n        \"\"\"Get the number of documents in the system\"\"\"\n        return len(self.documents)\n\n    def clear_documents(self):\n        \"\"\"Clear all documents from the system\"\"\"\n        self.documents = []\n        logger.info(\"All documents cleared from system\")","size_bytes":3016},"pyproject.toml":{"content":"[project]\nname = \"python-template\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Your Name <you@example.com>\"]\nrequires-python = \">=3.11\"\ndependencies = []\n","size_bytes":157},"backend/document_processor.py":{"content":"import os\nimport logging\nfrom typing import List\nimport PyPDF2\nfrom langchain.schema import Document\n\nlogger = logging.getLogger(__name__)\n\nclass DocumentProcessor:\n    def __init__(self):\n        \"\"\"Initialize the document processor\"\"\"\n        pass\n\n    def process_pdf(self, file_path: str) -> List[Document]:\n        \"\"\"Process a PDF file and extract text content\"\"\"\n        try:\n            documents = []\n\n            with open(file_path, 'rb') as file:\n                pdf_reader = PyPDF2.PdfReader(file)\n\n                for page_num, page in enumerate(pdf_reader.pages):\n                    try:\n                        text = page.extract_text()\n\n                        if text.strip():  # Only add non-empty pages\n                            doc = Document(\n                                page_content=text,\n                                metadata={\n                                    \"source\": file_path,\n                                    \"page\": page_num + 1,\n                                    \"total_pages\": len(pdf_reader.pages)\n                                }\n                            )\n                            documents.append(doc)\n\n                    except Exception as e:\n                        logger.warning(f\"Error extracting text from page {page_num + 1}: {e}\")\n                        continue\n\n            logger.info(f\"Processed {len(documents)} pages from {file_path}\")\n            return documents\n\n        except Exception as e:\n            logger.error(f\"Error processing PDF {file_path}: {e}\")\n            raise\n\n    def process_text_file(self, file_path: str) -> List[Document]:\n        \"\"\"Process a text file and extract content\"\"\"\n        try:\n            with open(file_path, 'r', encoding='utf-8') as file:\n                content = file.read()\n\n            doc = Document(\n                page_content=content,\n                metadata={\n                    \"source\": file_path,\n                    \"type\": \"text_file\"\n                }\n            )\n\n            logger.info(f\"Processed text file {file_path}\")\n            return [doc]\n\n        except Exception as e:\n            logger.error(f\"Error processing text file {file_path}: {e}\")\n            raise","size_bytes":2215}},"version":2}